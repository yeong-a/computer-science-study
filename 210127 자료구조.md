## ✔ 우선순위 큐(Priority Queue)
* qeueu란 데이터를 저장하는 자료구조의 한 종류로, FIFO(First In First Out)의 특징을 가진다. 즉 먼저 들어간 데이터가 먼저 나온다.
* enqueue는 데이터를 삽입하는 연산, dequeue는 데이터를 빼는 연산이다.
* 우선순위 큐는 큐의 기본 특징인 FIFO를 따르면서도 우선순위가 높은 데이터를 우선순위가 낮은 데이터보다 먼저 처리한다. 만약 우선순위가 같은 데이터가 여럿 있다면, 큐의 기본 특징인 FIFO에 따라 순서에 의해 처리한다.
* 우선순위 큐는 배열, 연결리스트, heap등으로 구현할 수 있는데 heap으로 구현하는 것이 가장 효율적이다.
* heap은 완전이진트리의 일종이며, 부모와 자식노드간의 대소관계가 보장되는 트리이다. 따라서 우선순위 큐에서 우선순위에 해당하는 최댓값이나 최솟값을 가장 쉽게 찾을 수 있기 때문이다.
#### heap의 추가와 삭제
* heap의 삽입은 노드의 맨 끝에 삽입, 삭제는 루트를 삭제하고 마지막 노드를 루트로 가져온다. 추가와 삭제 후에는 정렬을 해야한다.
#### 데큐(Deque)
* 데큐는 큐와 스택의 장점을 합쳐놓은 자료구조이다. 양쪽 끝에서 삽입과 삭제가 모두 가능하다.


## ✔ 연결 리스트(Linked List)
* 연결 리스트란 노드간의 연결로 데이터를 저장하는 자료구조이다.
* 노드에는 데이터와 포인터가 있어 다음 노드의 주소를 알 수 있다. 첫 노드를 가르키는 포인터를 head라고 하고, 마지막 노드를 가르키는 포인터를 tail이라고 한다.
* 연결 리스트의 종류에는 대표적으로 단일 연결 리스트(Singly Linked List)와 이중 연결 리스트(Doubley Linkes List)가 있다.
* 이중 연결 리스트에는 한 노드가 자신의 이전 노드의 참조와 다음 노드의 참조를 모두 갖고 있어, 양방향으로 이동할 수 있다.
* 연결 리스트의 장점은 크기가 가변적이라 데이터의 추가와 삭제가 배열에 비해 빠르다.
>연결 리스트의 각 노드들은 다음 노드를 가리키는 포인터를 갖고 있기 때문에 데이터를 추가하거나 삭제하고 노드를 포인터로 연결해주면 되기 때문이다.
>이에 비해 배열은 크기가 고정되어 있어 데이터의 추가와 삭제가 어렵다. 많은 데이터를 추가하기엔 크기가 고정적이고, 삭제할 때는 할당된 공간이 null이 되기 때문이다.
* 연결 리스트의 단점은 크게 두 가지가 있다.   
  * 노드에 포인터(참조 값)를 저장하고 있어서 배열에 비해 메모리 사용량이 크다. 
  * 원하는 값을 찾으려면 모든 노드를 처음부터 탐색해야 한다.
>배열은 연속적인 메모리를 할당받아 데이터를 저장하기 때문에 인덱스를 알고 있다면 원하는 곳에 바로 접근할 수 있다.   


## ✔ 스택으로 큐 구현하기

* 스택 두개를 사용하면 된다. 첫번째 스택에 데이터를 push하고, 데이터의 입력이 모두 끝나면 다음 스택으로 pop한다. 그리고 두번째 스택에서 pop을 하면 결과적으로 FIFO을 만족하게 된다.
  * enqeueu: 첫번째 스택으로 push
  * deqeueu: 첫번째 스택에서 두번째 스택으로 pop 한 후 두번재 스택에서 pop
  
#### 배열로 큐를 구현할 때의 문제점
* 배열의 길이가 정해진 경우, 데이터를 추가하고 삭제할 때마다 Front와 Rear가 계속 증가하여 용량이 줄어들어 결국에는 사용할 수 없게된다.
* 이러한 문제점을 해결하기 위해 큐의 시작과 끝을 순환할 수 있는 순환 큐(Circlear Queue)를 사용하면 된다.


## ✔ 해시충돌 해결방법
* 해싱(Hashing)이란, 어떤 문자열을 상징하는 더 짦은 문자열로 변환하는 것을 말한다.
* 예를 들어 장영아를 ㅈㅇㅇ으로 변환하는 것이다. 여기서 ㅈㅇㅇ을 버켓(bucket)이라고 부른다.
* 해싱은 원래의 것을 간소화하는 연산이기 때문에 필연적으로 해시 충돌이 일어날 수 밖에 없다. 
* 해시 충돌을 해결하는 방법은 크게 체이닝과 개방주소방법 등이 있다.
  * 체이닝은 같은 값의 해시를 갖는 원소를 연결리스트로 관리하는 방법이다.   
>사전을 예시로 들 수 있다. 선물과 신문을 해싱하면 모두 ㅅㅁ가 나오게 되지만 사전에서 'ㅅ'을 찾아가면 정의된 순서에 맞춰 단어의 뜻이 기술되어있다.
  * 개방주소방법은 체이닝처럼 추가 공간을 허용하지 않고 주어진 해쉬 테이블 공간 내에서 해결한다.
    * 선형탐색은 충돌한 원소를 다음 버켓이나 몇 개를 건너 뛴 버켓에 저장한다.
    * 제곱 탐색은 제곱만큼 건너뛴 버켓에 원소를 저장한다. 
    * 이중해시는 해싱을 한 번 더 적용한 결과를 이용한다.
    
#### 군집화
* 군집화란, 특정 value에 해시가 모이는 경우를 말한다.
* 군집화를 해결하기 위한 방법은 이중해싱이다. 해싱을 하면 데이터가 분산되기 때문에, 군집화를 해결할 수 있다.


## ✔ minimum spanning tree란?
* spanning tree는 그래프의 최소 연결 부분 그래프이다. n개의 정점을 가지는 그래프라면 spanning tree에서의 간선 수는 n-1개이다.
* minimum spanning tree란 간선에 가중치를 고려하여 최소 비용의 spannimg tree를 선택하는 것을 말한다. 즉, 모든 정점들을 가장 적은 수의 간선과 비용으로 연결하는 것이다. 

#### mst의 특징
* 간선의 가중치의 합이 최소여야 한다.
* n개의 정점을 가지는 그래프라면 간선의 수는 항상 n-1이다.
* 사이클이 포함되서는 안된다.

#### mst를 구하는 방법
>mst를 구하는 방법은 크게 스루스칼 알고리즘과 프림 알고리즘이 있다.   
>크루스칼 알고리즘은 엣지를 중심으로 생각을 하는 방법이다.우선 엣지를 전부 제외하고 노드만 있다고 생각하자.    
>엣지의 가중치를 하나씩 비교하면서 가장 가중치가 작은 엣지들부터 하나씩 추가를 하며 mst를 찾는다.   
>엣지를 추가할 때 그래프를 만들지 않는지 확인하며 트리형태를 갖추게 된다.   
>프림 알고리즘은 크루스칼과 반대로 노드를 하나씩 추가하는 방법이다.   
>맨 처음 노드를 선정하고 그 노드에 연결되어 있는 가장 작은 가중치를 가지는 엣지를 선택하는 방법이다.   
>그 다음부터는 처음 노드와 연결된 노드 모두 고려하여 가장 작은 가중치의 엣지를 계속 선택한다.    
>마찬가지로 그래프를 만들지 않는지 확인하면서 트리형태를 갖추게 된다.   
* 트리과 그래프의 차이점은 노드로 가는 길이 한가지냐 여러가지냐의 차이이다.


## ✔ 정렬(sort)과 시간 복잡도
* 정렬은 크게 안정 정렬과 불안정 정렬로 나뉜다.
* 예를 들어 1 2 4 1 5를 오름차순인 1 1 2 4 5로 정렬할 때 1의 순서가 바뀌지 않으면 안정 정렬, 바뀌면 불안정 정렬이다.
* 순서를 보장해야 한다면 안정 정렬을 써야한다.

#### 안정 정렬과 불안정 정렬의 종류
* 안정 정렬
  * 삽입 정렬 (Insert Sort) - O(n^2)
  * 버블 정렬 (Bubble Sort) - O(n^2)
  * 병합 정렬 (Merge Sort) - O(nlogn)
* 불안정 정렬
  * 선택 정렬 (Selection Sort) - O(n^2)
  * 퀵 정렬 (Quick Sort) - O(nlogn)
  * 힙 정렬 (Heap Sort) - O(nlogn)
  * 인트로 정렬 (Intro Sort) - O(nlogn)
